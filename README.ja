# -*- rd -*-

= README.ja

$Id$

木村さんがFreeBSDのportsを((<用意|URL:http://lists.sourceforge.jp/mailman/archives/gauche-devel-jp/2003-November/000437.html>))してくれました．

== 作者

Kouhei Sutou <kou@cozmixng.org>

== ライセンス

GPL or BSD License

== メーリングリスト

((<COZMIXNG RWiki - 連絡先|URL:http://www.cozmixng.org/~rwiki/index.rb?cmd=view;name=%CF%A2%CD%ED%C0%E8>))を御覧下さい．

== なにこれ？

GaUnitはGaucheで実装されたUnit Testing Frameworkです．おまけ
でテストの実行を支援するEmacs-Lispが付いています．

同様のものに
((<SchemeUnit|URL:http://schematics.sourceforge.net/schemeunit.html>))
があります．

== 読めねぇよ

「ごにっと」とかはどうでしょう？

== 入手方法

((<URL:http://www.cozmixng.org/~kou/download/gaunit.tar.gz>))

  % svn co http://www.cozmixng.org/repos/gauche/gaunit/trunk gaunit

== インストール

  # gosh install/install.scm

== 使い方

  (use test.unit)

  (define-test-suite ...)
  とか
  (define-test-case ...)
  とか

test.unitは一般的過ぎるので変更されるかもしれません．

=== リファレンス

==== 表明(?)

GaUnitは以下に示すテストをするための手続きを用意しています．

((|[message]|))はオプションです．失敗時のメッセージである文
字列か，引数をひとつとる手続きを指定します．手続きの場合はテ
スト結果が引数として渡されます．

--- fail([message])
    
    必ず失敗します．

--- assert(pred expected actual [message])
    
    (pred expected actual)が#fでないならば成功します．

--- assert-equal(expected actual [message])
    
    (equal? expected actual)が#tを返せば成功します．

--- assert-true(actual [message])
    
    actualが#tならば成功します．

--- assert-false(actual [message])
    
    actualが#fならば成功します．

--- assert-instance-of(expected-class object [message])
    
    objectがexpected-classのインスタンスであれば成功します．

--- assert-raise(expected-class thunk [message])
    
    thunk(引数無しの手続き)内で起こった例外がexpected-class
    のインスタンスであれば成功します．

--- assert-error(tunk [message])
    
    thunk(引数無しの手続き)内で例外が発生すれば成功します．

--- assert-each(assert-proc lst &keyword :run-assert :prepare)
    
    assert-procをlstの各要素に対して適用します．
    
    lstの各要素はprepareに適用され，run-assertによって
    assert-procに適用されます．
    
    イメージとしてはこんな感じです．

      (define (run-assert assert-proc args)
        (apply assert-proc args))
      (for-each (lambda (item)
                  (run-assert assert-proc (prepare item)))
                lst)

--- assert-macro(expanded form [message])
    
    (equal? expanded (macroexpand form))が真を返せば成功します．
    
--- assert-macro1(expanded form [message])
    
    (equal? expanded (macroexpand-1 form))が真を返せば成功します．
    
==== 必要最小限

GaUnitは以下の手続きを用意しています．

--- run-all-test(&keyword :ui)

    define-test-case, define-test-suiteで定義されたテストを
    実行します．
    
    また，キーワード引数:uiを指定することによりテストを
    実行するユーザインターフェイスを変更できます．が，現在は
    テキストベースのものしか用意されていません．

GaUnitは以下の構文を用意しています．

--- define-test-case
    
    テストケースを定義します．
    
      (define-test-case "テストケース名"
        (setup テストが実行される前に実行される引数無しの手続き) ; 必要なら
        (teardown テストが実行された後に実行される引数無しの手続き) ; 必要なら
        ("テスト名"
          (assertなんとか ...))
        ...)

--- define-test-suite
    
    テストスイートを定義します．
    
      (define-test-suite "テストスイート名"
        ("テストケース名"
          (setup テストが実行される前に実行される引数無しの手続き) ; 必要なら
          (teardown テストが実行された後に実行される引数無しの手続き) ; 必要なら
          ("テスト名"
            (assertなんとか)
            ...)
          ...)
        ...)

==== 必要なら

GaUnitは以下の手続きを用意しています．

--- run(<test-suite> or <test-case> or <test> &keyword :ui)

    テストを実行します．
    
    キーワード引数:uiを指定することによりテストを実行するユー
    ザインターフェイスを変更できます．

GaUnitは以下の構文を用意しています．

--- define-assertion
    
    assertion(表明?)を定義します．
    
      (define-assertion (表明名 引数 ...)
        式の列:最後の式の値が成功か失敗か示す)
    
    ((|式の列|))の値が<assertion-failure>クラスのオブジェク
    トなら失敗，それ以外なら成功を示します．詳しくは
    lib/test/assertions.scmのdefine-assertionを使って定義さ
    れているassertionを見てください．

--- make-test
    
    テストを定義します．

--- make-test-case
    
    テストケースを定義します．

--- make-test-suite
    
    テストスイートを定義します．

== 付属品

以下のものが付属しています．

=== run-test.el

sample/site-lisp/run-test.elはEmacs上でのテストの実行を支援
するEmacs-Lispです．

使うには，まず，.emacsに以下を記述します．

  (setq load-path (cons run-test.elがあるディレクトリ load-path))
  (load "run-test")

テストを実行するスクリプトrun-test.shを書きます．例えば，こ
んな感じです．

  #!/bin/sh

  for test in test/test-*.scm
  do
    echo "Running test $test..."
    gosh $test
  done

あるいは，run-test.scmとしてこんな感じでもいいです．

  #!/usr/bin/env gosh

  (use file.util)
  (use test.unit)

  (if (symbol-bound? 'main)
      (define _main main))

  (define (main args)
    (let ((dir (sys-dirname (car args))))
      (for-each (lambda (test-script)
                  (print "loading " (string-join
                                     (list dir test-script)
                                     "/"))
                  (load (string-join (list dir test-script) "/")))
                (directory-list dir
                                :filter (lambda (x) (rxmatch #/^test-/ x)))
                )
      (if (symbol-bound? '_main)
          (_main args)
          (run-all-test))))


で，testというディレクトリを作って，このrun-test.shあるいは
run-test.scmに実行権を付けておいておきます．

テストファイルはtestというディレクトリ以下にtest-hoge.scmと
いう名前で作っていきます．つまり，ディレクトリ構成は以下の様
になります．

  topdir --- test --- run-test.sh or run-test.scm
                   |
                   +- test-hoge.scm
                   |
                   .
                   .
                   .
                   |
                   +- test-fuga.scm

テスト(run-test.scm)はtopdirで起動されます．つまり，

  % test/run-test.sh

というように起動されます．

run-test.{sh,scm}を書くときはこのことに注意しましょう．

設定はこれで終了です．

topdirから3階層まで深いディレクトリ内ではC-cC-t(run-test)で
topdir/test/run-test.shが実行できます．実行結果は
*Compilation*バッファに挿入されます．テストを実行して失敗/エ
ラーがおきたらエラーが発生したassertionにC-x`でジャンプする
ことができます．

これで手軽に頻繁にテストを実行できますね．Happy testing!!

==== カスタマイズ変数

: run-test-file
   テストを実行するスクリプトの拡張子を除いたファイル名です．
   
   デフォルト: "test/run-test"

: run-test-suffixes
   run-test-fileに付加する拡張子のリストです．先頭の方にある拡張子程
   優先されます．
   
   デフォルト: (".scm" ".rb" ".sh")

: run-test-search-directories
   run-test-fileを探索するディレクトリのリストです．先頭の方
   にあるディレクトリ程優先されます．
   
   デフォルト: ("./" "../" "../../" "../../../")
